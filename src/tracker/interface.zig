/// A tracker has an announceFn and its callback
/// The callback is to be provided when creating the Tracker. callback is expected to be called
/// whenever a response is recieved from announce.
/// See: `factory.zig`
pub const Client = struct {
    ptr: *anyopaque,
    _announceFn: AnnounceFunction,
    _deinit: DeinitFunction,

    pub fn announce(self: Client, data: *AnnounceRequest) !void {
        return self._announceFn(self.ptr, data);
    }

    pub fn deinit(self: Client) void {
        return self._deinit(self.ptr);
    }

    pub const Event = enum {
        none,
        /// The first request to the tracker must include the event key with this value.
        started,
        /// Must be sent to the tracker if the client is shutting down gracefully.
        stopped,
        /// Must be sent to the tracker when the download completes. However, must not be sent if the download was
        /// already 100% complete when the client started. Presumably, this is to allow the tracker to increment the
        /// "completed downloads" metric based solely on this event.
        completed,
    };

    pub const AnnounceRequest = struct {
        /// SHA1 hash of the bencoded value of the info key from the Metainfo.
        /// 20 byte size
        info_hash: []const u8,

        /// Peer details of ourselves.
        peer: Peer,

        /// The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        /// While not explicitly stated in the official specification, the concensus is that this should be the total
        /// number of bytes uploaded.
        uploaded: u128,

        /// The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        /// While not explicitly stated in the official specification, the concensus is that this should be the total
        /// number of bytes downloaded.
        downloaded: u128,

        /// The number of bytes this client still has to download in base ten ASCII. Clarification: The number of bytes
        /// needed to download to be 100% complete and get all the included files in the torrent.
        left: u128,

        /// Setting this to true indicates that the client accepts a compact response. The peers list is replaced by a
        /// peers string with 6 bytes per peer. The first four bytes are the host (in network byte order), the last two
        /// bytes are the port (again in network byte order). It should be noted that some trackers only support compact
        /// responses (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact
        /// response unless the request contains "compact=0" (in which case they will refuse the request.)
        /// NOTE: not supported by all trackers.
        compact: bool = false,

        /// Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
        no_peer_id: bool = false,

        event: Event,

        /// Number of peers that the client would like to receive from the tracker. This value is permitted to be zero.
        /// If omitted, typically defaults to 50 peers.
        numwant: u32 = 50,

        /// An additional identification that is not shared with any other peers. It is intended to allow a client to
        /// prove their identity should their IP address change.
        key: ?i32 = null,

        /// Optional. If a previous announce contained a tracker id, it should be set here.
        tracker_id: ?i32 = null,
    };

    pub const Peer = struct {
        /// 20 byte unique ID for the client, generated by the client at startup. This is allowed to be any value,
        /// and may be binary data. There are currently no guidelines for generating this peer ID. However, one may rightly presume
        /// that it must at least be unique for your local machine, thus should probably incorporate things like
        /// process ID and perhaps a timestamp recorded at startup.
        /// See peer_id below for common client encodings of this field.
        peer_id: []const u8,

        /// The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address.
        /// Notes: In general this parameter is not necessary as the address of the client can be determined from the IP
        /// address from which the HTTP request came. The parameter is only needed in the case where the IP address that
        /// the request came in on is not the IP address of the client. This happens if the client is communicating to
        /// the tracker through a proxy (or a transparent web proxy/cache.) It also is necessary when both the client
        /// and the tracker are on the same local side of a NAT gateway. The reason for this is that otherwise the
        /// tracker would give out the internal (RFC1918) address of the client, which is not routable. Therefore the
        /// client must explicitly state its (external, routable) IP address to be given out to external peers. Various
        /// trackers treat this parameter differently. Some only honor it only if the IP address that the request came
        /// in on is in RFC1918 space. Others honor it unconditionally, while others ignore it completely. In case of
        /// IPv6 address (e.g.: 2001:db8:1:2::100) it indicates only that client can communicate via IPv6.
        ip: []const u8,

        // The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889.
        // Clients may choose to give up if it cannot establish a port within this range.
        port: u32,
    };

    pub const AnnounceResponse = struct {
        /// if failure is present, other keys are not required.
        failure: ?[]const u8,

        /// maps to the number of seconds the downloader should wait between regular rerequests.
        /// Note that downloaders may rerequest on nonscheduled times if an event happens or they need more peers.
        interval: ?i128,

        peers: ?[]Peer,
    };

    pub const AnnounceFunctionCallback = *const fn (data: *AnnounceResponse) anyerror!void;
    pub const AnnounceFunction = *const fn (ptr: *anyopaque, data: *AnnounceRequest) anyerror!void;
    pub const DeinitFunction = *const fn (ptr: *anyopaque) void;
};
